# How to write firmware on STM32

Be aware that you often manipulate lots of distinct entities, which you are putting together (linking). For example, you might have to use FreeRTOS, HAL, a sensor API and code generated by CubeMX. They are all things that are necessary, but you must be careful, because sometimes you do not know where the things are done. For example, your sensor tells that you have to initialize I2C, whereas it is already done by CubeMX. 

So, the way to go is to always start at the higher level, and see what is done there (in `main.c`). Then, if you see that something is missing, you have to dive in the lower levels and write it (once you know what exactly you need!).

## HAL

THe Hardware Abstraction Layer (HAL) contains all the functions necessary to interact with the hardware -> it is always used at lower level. It is a driver. When using HAL, be sure to check the user manual ([Description of STM32F3 HAL and low-layer drivers](https://ikea.octanis.ch/index.php/apps/files/?dir=/Octanis%20Instruments/Engineering/STM32_fw&fileid=83148#pdfviewer)), which will document all the existing functions, and inform you on what functions have to be called before.

## Debugging

When you are writing really low level code, the only way to debug is to use the **oscilloscope** and see what are the bits that are being sent. You should not trust the debugger in Vscode because it is only interpreting what is going on -> not showing you what is actually happening at bits level.

Another possibility is to use a **logic analyzer** (e.g.: Analog Discovery 2).

However, to make it work, you have to make sure to **remove the `-oG` option** in the `Makefile`. Otherwise, the code is optimized and the debugger is not able to access the registers values.

Also, the debugger doesn't work really well if they are more than 6 break points.

## Threads memory allocation

Since we use [FreeRTOS](./freertos.md), we have different tasks running in parallel on the MCU. There might be the case where the code is crashing because a thread is trying to access more memory than it has been allocated, so always check that!

Also, it might happen that the size allocated to the whole heap is too small. You can check that in the `FreeRTOSConfig.h` file:

```C
#define configTOTAL_HEAP_SIZE   ((size_t)13072) // number of bytes
```
